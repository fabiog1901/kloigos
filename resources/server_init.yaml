---
#
# Playbook invoked by Kloigos after each `init_server` call.
#
# The following extra-vars are passed:
#   hostname
#   ip
#   user_id
#   cpu_ranges
#   cpu_sets
#   port_ranges
#
- name: GATHER NEW SERVER TO INIT
  hosts: localhost
  connection: local
  gather_facts: no
  become: no
  tasks:
    - name: Build ansible inventory dynamically
      add_host:
        name: "{{ hostname }}"
        ansible_user: "{{ user_id }}"
        public_hostname: "{{ hostname }}"
        ansible_host: "{{ ip }}"
        public_ip: "{{ ip }}"
        groups: init_server

- name: INIT NEW SERVER
  hosts: init_server
  gather_facts: no
  become: yes
  tasks:
    - name: create users
      shell: |
        id c{{ item }} || useradd --create-home --home-dir /home/c{{ item }} --shell /bin/bash c{{ item }}
      loop: "{{ cpu_ranges }}"

    - name: Find attached disks
      shell: |
        # 1. Get the device path for the root partition
        ROOTLOC=$(lsblk -plo NAME,MOUNTPOINTS | grep -w '/$' | awk '{print $1}')

        # 2. Identify the physical parent disk
        ROOTDISK=$(lsblk -no PKNAME "$ROOTLOC")

        # 3. List disks excluding the OS parent disk
        # Use single backslash for awk in a | block
        lsblk -dpno NAME,TYPE | grep -w 'disk' | grep -vw "$ROOTDISK" | awk '{print $1}'
      args:
        executable: /bin/bash
      register: disks

    - name: Create a ext4 filesystem
      shell: |
        blkid {{ item }} -t TYPE="ext4" || mkfs.ext4 {{ item }}
      loop: "{{ disks.stdout_lines }}"

    - name: add disks to /etc/fstab
      shell: |
        mkdir -p /mnt/c{{ item.1 }}
        DISKUUID=`lsblk -no UUID {{ item.0 }}`
        grep -q $DISKUUID /etc/fstab || echo "UUID=$DISKUUID /mnt/c{{ item.1 }} ext4 defaults 0 2" >> /etc/fstab
      loop: "{{ disks.stdout_lines | zip(cpu_ranges) | list }}"

    - name: reload systemd and mount disks
      shell: |
        systemctl daemon-reload
        mount --all

    - name: create directories and setting ownership
      shell: |
        mkdir -p /opt/c{{ item }}
        mkdir -p /mnt/c{{ item }}
        mkdir -p /home/c{{ item }}
        mkdir -p /home/c{{ item }}/.ssh
        chown -R c{{ item }}:c{{ item }} /opt/c{{ item }}
        chown -R c{{ item }}:c{{ item }} /mnt/c{{ item }}
        chown -R c{{ item }}:c{{ item  }} /home/c{{ item }}
        chmod 0750 /opt/c{{ item }}
        chmod 0750 /mnt/c{{ item }}
        chmod 0750 /home/c{{ item }}
      loop: "{{ cpu_ranges }}"

    - name: finding id for each user
      shell: |
        id -u c{{ item }}
      loop: "{{ cpu_ranges }}"
      register: user_ids

    - name: create directory for delegate.conf
      shell: |
        mkdir -p /etc/systemd/system/user@.service.d

    - name: write user service delegate.conf
      copy:
        content: |
          [Service]
          Delegate=yes
          DelegateControllers=cpuset cpu io memory pids

        dest: /etc/systemd/system/user@.service.d/delegate.conf

    - name: creating user slice and nft directories
      shell: |
        mkdir -p /etc/systemd/system/user-{{ item.stdout }}.slice.d
        mkdir -p /etc/nftables.d
      loop: "{{ user_ids.results }}"

    - name: allocate memory proportionate to the compute unit cpu count
      shell: |
        MEM_TOT=`cat /proc/meminfo | grep "MemTotal" | awk '{print $2}'`
        CPU_COUNT=`cat /proc/cpuinfo | grep -c processor`
        echo $MEM_TOT / $CPU_COUNT | bc
      register: mem_kb_per_cpu

    - name: get cpu,numa_node from lscpu
      shell: |
        lscpu -p=CPU,NODE | grep -v '#'
      register: lscpu_p

    - name: Build cpu_to_node dict from lscpu
      set_fact:
        cpu_to_node: "{{ cpu_to_node | default({}) | combine({ (item.split(',')[0]): (item.split(',')[1]) }) }}"
      loop: "{{ lscpu_p.stdout_lines }}"

    - name: write user slice override
      copy:
        content: |
          [Slice]

          # CPUSET PINNING
          AllowedCPUs={{ item.1 }}

          # Resource controls (tune as needed)
          CPUAccounting=yes
          MemoryAccounting=yes
          IOAccounting=yes

          # Max number of processes allowed
          TasksMax=2048

          # IOWeight=100

          # MEMORY ALLOCATION
          #
          AllowedMemoryNodes={{ cpu_to_node[item.1.split(',')[0]] }}
          MemoryNodes={{ cpu_to_node[item.1.split(',')[0]] }}
          MemoryHigh={{ (item.1.split(',') | length * mem_kb_per_cpu.stdout | int / 1024 / 1024) | round(0, 'floor') | int }}G
          MemoryMax={{ (item.1.split(',') | length * mem_kb_per_cpu.stdout | int * 0.9 / 1024 / 1024) | round(0, 'floor') | int }}G

          # BIND PORTS
          # 
          # SocketBindAllow/Deny is implemented using systemd’s BPF framework.
          # If your systemd is not built with that support, 
          # the settings will appear in `systemctl show ...`,
          # but won’t be enforced. 
          # This is a known real-world case (e.g., certain Debian builds).
          # Quickly check support by executing `systemd --version` and
          # look for +BPF / +BPF_FRAMEWORK in the feature list.
          #
          SocketBindDeny=any
          SocketBindAllow=ipv4:tcp:{{ item.2 }}
          SocketBindAllow=ipv4:udp:{{ item.2 }}
          SocketBindAllow=ipv6:tcp:{{ item.2 }}
          SocketBindAllow=ipv6:udp:{{ item.2 }}

        dest: /etc/systemd/system/user-{{ item.0.stdout }}.slice.d/50-kloigos.conf
      loop: "{{ user_ids.results | zip(cpu_sets, port_ranges) | list }}"

    - name: restart logind
      shell: |
        systemctl daemon-reload
        systemctl restart systemd-logind

    - name: restart user slice and user service and enable linger
      shell: |
        systemctl restart user@{{ item.0.stdout }}.service
        systemctl restart user-{{ item.0.stdout }}.slice
        loginctl enable-linger c{{ item.1 }}
      loop: "{{ user_ids.results | zip(cpu_ranges) | list }}"

    - name: enforce disk util
      shell: |
        # Optional: enforce 100GB caps on /home and /opt subtrees via ext4 project quotas
        # This requires /home and /opt filesystems to be mounted with prjquota.
        # Choose stable project IDs (example scheme: 11003/21003 for CU1, 11007/21007 for CU2)
        # echo "[*] optional: setting 100GB directory quotas (requires prjquota + quota tools)"

        # maybe_setup_dir_quota "11003" "home_u0_3" "$HOME1" "/home"
        # maybe_setup_dir_quota "11007" "home_u4_7" "$HOME2" "/home"
        # maybe_setup_dir_quota "21003" "opt_c0_3"  "$OPT1"  "/opt"
        # maybe_setup_dir_quota "21007" "opt_c4_7"  "$OPT2"  "/opt"

    - name: create kloigos-apt
      copy:
        content: |
          #!/bin/bash
          set -euo pipefail

          case "$1" in
            install|remove|purge|update)
              ;;
            *)
              echo "Unsupported apt action"
              exit 1
              ;;
          esac

          exec /usr/bin/apt "$@"
        dest: /usr/local/bin/kloigos-apt

    - name: set kloigos-apt permissions and ownership
      shell: |
        chown root:root /usr/local/bin/kloigos-apt
        chmod 0755 /usr/local/bin/kloigos-apt

    - name: make source repos files immutable
      shell: |
        # Let’s break down exactly what your command does and why it matters.
        # The command marks:
        #   /etc/apt/sources.list
        #   all files in /etc/apt/sources.list.d/
        # as immutable.
        # “Immutable” means:
        # Once set, the file cannot be modified, deleted, renamed, truncated, 
        # replaced, have permissions changed, have ownership changed
        # Even root cannot modify it until the flag is removed.

        chattr +i /etc/apt/sources.list  #/etc/apt/sources.list.d/*.list

    - name: create sudoers directory
      shell: |
        mkdir -p /etc/sudoers.d/

    - name: create sudoers files to run kloigos-apt
      copy:
        content: |
          c{{ item }} ALL=(root) NOPASSWD: /usr/local/bin/kloigos-apt
          Defaults:c{{ item }} env_reset
          Defaults:c{{ item }} secure_path="/usr/sbin:/usr/bin:/sbin:/bin:/usr/local/bin"

        dest: /etc/sudoers.d/kloigos-c{{ item }}
      loop: "{{ cpu_ranges }}"
