{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"VM-like isolation. Bare-metal performance. No orchestration.","text":""},{"location":"#kloigos-lets-you-split-a-powerful-server-into-multiple-independent-compute-environments-without-virtual-machines-or-containers","title":"Kloigos lets you split a powerful server into multiple independent compute environments - without virtual machines or containers","text":"<p>Kloigos is a Linux-native control plane for managing compute units: lightweight, VM-like execution environments carved directly out of a host using standard Linux primitives.</p> <p>Instead of relying on virtual machines or container orchestration, Kloigos subdivides large servers into isolated compute units by combining CPU pinning, resource limits, filesystem isolation, and network controls.</p> <p>Each compute unit behaves like a small, dedicated machine, with its own Unix user, SSH access, and systemd-managed services - while sharing the host kernel and avoiding virtualization overhead.</p> <p>It gives teams a simple, VM-like way to run multiple workloads on the same host, with predictable performance, strong isolation, and a familiar Linux experience. No orchestration layers, no images, no extra overhead - just efficient use of the hardware you already have.</p>"},{"location":"#benefits","title":"Benefits","text":"<p>Kloigos makes it easy to divide a single machine into multiple isolated compute units, each with its own resources, user space, and lifecycle. It offers the convenience of virtual machines without the complexity or cost of virtualization.</p> <p>Kloigos allows you to run multiple independent workloads on the same host with predictable performance and minimal overhead. By building directly on Linux primitives, it delivers VM-like isolation while staying fast, simple, and transparent.</p> <p>Each compute unit behaves like a lightweight VM - with SSH access, systemd services, and isolated resources - while avoiding the complexity of containers and hypervisors. It\u2019s a pragmatic way to share powerful servers without surprises.</p>"},{"location":"about/","title":"About","text":"<p>The name comes from the Greek word \u03c0\u03bb\u03bf\u03b7\u03b3\u03cc\u03c2 (ploigos), which means \"navigator\", but substituting \u03c0 (Pi) with \u039a (Kappa), so \u039a\u03bb\u03bf\u03b7\u03b3\u03cc\u03c2.</p>"},{"location":"api/","title":"\u039a\u03bb\u03bf\u03b7\u03b3\u03cc\u03c2 / Kloigos API","text":"<p>Version: <code>0.2.0</code></p> <p>Base URL: <code>/api</code></p>"},{"location":"api/#compute_units","title":"\ud83d\uddc2\ufe0f compute_units","text":""},{"location":"api/#post-compute_unitsallocate","title":"\ud83d\udfe9 <code>POST /compute_units/allocate</code>","text":"<p>Allocate</p> <p>Request body (JSON): <code>ComputeUnitRequest</code></p> <p>Responses:</p> <ul> <li> <p>\u2705 <code>200</code> \u2192 <code>ComputeUnitResponse</code></p> </li> <li> <p>\u274c <code>422</code> \u2192 <code>HTTPValidationError</code></p> </li> </ul>"},{"location":"api/#delete-compute_unitsdeallocatecompute_id","title":"\ud83d\udfe5 <code>DELETE /compute_units/deallocate/{compute_id}</code>","text":"<p>Deallocate</p> <p>Parameters:</p> <ul> <li>\u2757 <code>compute_id</code> \ud83d\udd24</li> </ul> <p>Responses:</p> <ul> <li> <p>\u2705 <code>200</code> \u2192 <code>{}</code></p> </li> <li> <p>\u274c <code>422</code> \u2192 <code>HTTPValidationError</code></p> </li> </ul>"},{"location":"api/#get-compute_units","title":"\ud83d\udfe6 <code>GET /compute_units/</code>","text":"<p>List Servers</p> <p>Returns a list of all servers. Optionally filter the results by 'deployment_id' or 'status' query parameters.</p> <p>Example: - /servers - /servers?deployment_id=web_app_v1 - /servers?status=free</p> <p>Parameters:</p> <ul> <li>\u2796 <code>compute_id</code> \ud83d\udd24 \ud83d\udeab</li> <li>\u2796 <code>hostname</code> \ud83d\udd24 \ud83d\udeab</li> <li>\u2796 <code>region</code> \ud83d\udd24 \ud83d\udeab</li> <li>\u2796 <code>zone</code> \ud83d\udd24 \ud83d\udeab</li> <li>\u2796 <code>cpu_count</code> \ud83d\udd22 \ud83d\udeab</li> <li>\u2796 <code>deployment_id</code> \ud83d\udd24 \ud83d\udeab</li> <li>\u2796 <code>status</code> \ud83d\udd24 \ud83d\udeab</li> </ul> <p>Responses:</p> <ul> <li> <p>\u2705 <code>200</code> \u2192 <code>array[ComputeUnitResponse]</code></p> </li> <li> <p>\u274c <code>422</code> \u2192 <code>HTTPValidationError</code></p> </li> </ul>"},{"location":"api/#admin","title":"\ud83d\uddc2\ufe0f admin","text":""},{"location":"api/#post-admininit_server","title":"\ud83d\udfe9 <code>POST /admin/init_server</code>","text":"<p>Init Server</p> <p>Request body (JSON): <code>InitServerRequest</code></p> <p>Responses:</p> <ul> <li> <p>\u2705 <code>200</code> \u2192 <code>{}</code></p> </li> <li> <p>\u274c <code>422</code> \u2192 <code>HTTPValidationError</code></p> </li> </ul>"},{"location":"api/#delete-admindecommission_serverhostname","title":"\ud83d\udfe5 <code>DELETE /admin/decommission_server/{hostname}</code>","text":"<p>Decommission Server</p> <p>Parameters:</p> <ul> <li>\u2757 <code>hostname</code> \ud83d\udd24</li> </ul> <p>Responses:</p> <ul> <li> <p>\u2705 <code>200</code> \u2192 <code>{}</code></p> </li> <li> <p>\u274c <code>422</code> \u2192 <code>HTTPValidationError</code></p> </li> </ul>"},{"location":"api/#schemas","title":"\ud83e\uddf1 Schemas","text":""},{"location":"api/#computeunitrequest","title":"ComputeUnitRequest","text":"<p>Required:</p> <ul> <li><code>ssh_public_key \ud83d\udd24</code></li> <li><code>tags \ud83d\udce6 \ud83d\udeab</code></li> </ul> <p>Optional:</p> <ul> <li><code>cpu_count</code> \ud83d\udd22 \ud83d\udeab default: <code>4</code></li> <li><code>region</code> \ud83d\udd24 \ud83d\udeab</li> <li><code>zone</code> \ud83d\udd24 \ud83d\udeab</li> </ul>"},{"location":"api/#computeunitresponse","title":"ComputeUnitResponse","text":"<p>Required:</p> <ul> <li><code>started_at \ud83d\udd24 \ud83d\udeab</code></li> <li><code>ip \ud83d\udd24</code></li> <li><code>ports_range \ud83d\udd24 \ud83d\udeab</code></li> <li><code>cpu_range \ud83d\udd24</code></li> <li><code>tags \ud83d\udce6 \ud83d\udeab</code></li> <li><code>compute_id \ud83d\udd24</code></li> <li><code>region \ud83d\udd24</code></li> <li><code>zone \ud83d\udd24</code></li> <li><code>cpu_list \ud83d\udd24</code></li> <li><code>hostname \ud83d\udd24</code></li> <li><code>status \ud83d\udd24</code></li> <li><code>cpu_count \ud83d\udd22</code></li> </ul>"},{"location":"api/#httpvalidationerror","title":"HTTPValidationError","text":"<p>Optional:</p> <ul> <li><code>detail</code> array[ValidationError]</li> </ul>"},{"location":"api/#initserverrequest","title":"InitServerRequest","text":"<p>Required:</p> <ul> <li><code>ip \ud83d\udd24</code></li> <li><code>region \ud83d\udd24</code></li> <li><code>zone \ud83d\udd24</code></li> <li><code>cpu_ranges array[\ud83d\udd24]</code></li> <li><code>hostname \ud83d\udd24</code></li> </ul>"},{"location":"api/#validationerror","title":"ValidationError","text":"<p>Required:</p> <ul> <li><code>type \ud83d\udd24</code></li> <li><code>msg \ud83d\udd24</code></li> <li><code>loc array[\ud83d\udd24 \ud83d\udd22]</code></li> </ul>"},{"location":"use-case/","title":"Use Case","text":"<p>Kloigos is a Linux-native control plane for managing compute units: lightweight, VM-like execution environments carved directly out of a host using standard Linux primitives.</p>"},{"location":"use-case/#the-problem-kloigos-solves","title":"The problem Kloigos solves","text":"<p>On modern servers with dozens or hundreds of CPUs, teams often need to run multiple independent workloads on the same machine while maintaining:</p> <ul> <li> <p>predictable CPU and resource allocation</p> </li> <li> <p>strong isolation between workloads</p> </li> <li> <p>a familiar, VM-like user experience (SSH, systemd, writable filesystem)</p> </li> <li> <p>minimal operational overhead</p> </li> </ul> <p>Traditional solutions - virtual machines, containers, or Kubernetes - can be too heavy, too complex, or too opinionated for this use case. Kloigos fills the gap by providing fine-grained, host-level isolation without introducing a hypervisor or container runtime.</p>"},{"location":"use-case/#use-case-for-kloigos","title":"Use case for Kloigos","text":"<p>Kloigos can be broadly useful - but only for a specific class of users and environments. It\u2019s not a universal replacement for VMs, containers, or Kubernetes, and that\u2019s actually a strength, not a weakness.</p> <p>Let\u2019s frame this clearly.</p>"},{"location":"use-case/#1-what-problem-kloigos-really-solves","title":"1. What problem Kloigos really solves","text":"<p>At its core, Kloigos solves this problem:</p> <p>\u201cHow do I safely and efficiently subdivide a large Linux server into multiple VM-like environments without a hypervisor or container stack, while keeping a familiar SSH + systemd user experience?\u201d</p> <p>That problem exists far more often than people realize, especially outside hyperscale cloud-native teams.</p> <p>Kloigos is most compelling where people want:</p> <ul> <li>strong isolation</li> <li>very low overhead</li> <li>standard Linux tooling</li> <li>no Kubernetes</li> <li>no hypervisor</li> <li>no image pipelines</li> </ul>"},{"location":"use-case/#2-who-would-find-kloigos-immediately-useful","title":"2. Who would find Kloigos immediately useful","text":""},{"location":"use-case/#1-infrastructure-platform-teams-with-large-bare-metal-servers","title":"1) Infrastructure / platform teams with large bare-metal servers","text":"<p>Common in:</p> <ul> <li>finance / trading</li> <li>telco</li> <li>research labs</li> <li>enterprise data centers</li> <li>on-prem AI / ML clusters</li> </ul> <p>These teams often have:</p> <ul> <li>64-256 core machines</li> <li>predictable workloads</li> <li>strong isolation requirements</li> <li>skepticism toward Kubernetes overhead</li> </ul> <p>Kloigos lets them:</p> <ul> <li>slice machines deterministically</li> <li>assign ownership cleanly</li> <li>avoid VM sprawl</li> <li>keep performance predictable</li> </ul>"},{"location":"use-case/#2-teams-running-pet-services-rather-than-cattle","title":"2) Teams running \u201cpet services\u201d rather than cattle","text":"<p>Not every workload fits the container model.</p> <p>Examples:</p> <ul> <li>stateful services</li> <li>legacy daemons</li> <li>services that expect a writable filesystem</li> <li>software that assumes SSH access</li> <li>systemd-managed services</li> <li>licensed software bound to host identity</li> </ul> <p>Kloigos gives them:</p> <ul> <li>isolation without rewriting deployment models</li> <li>an EC2-like mental model</li> <li>predictable CPU and IO placement</li> </ul>"},{"location":"use-case/#3-multi-tenant-environments-with-trusted-but-isolated-users","title":"3) Multi-tenant environments with trusted but isolated users","text":"<p>Examples:</p> <ul> <li>internal developer platforms</li> <li>shared build servers</li> <li>CI runners</li> <li>academic compute clusters</li> <li>training environments</li> </ul> <p>These environments need:</p> <ul> <li>real isolation</li> <li>fair resource usage</li> <li>simple cleanup</li> <li>minimal ops burden</li> </ul> <p>Kloigos fits perfectly here.</p>"},{"location":"use-case/#4-performance-sensitive-workloads","title":"4) Performance-sensitive workloads","text":"<p>Kloigos avoids:</p> <ul> <li>VM exits</li> <li>container overlay filesystems</li> <li>network overlays</li> <li>extra scheduler layers</li> </ul> <p>This matters for:</p> <ul> <li>low-latency services</li> <li>HPC-style workloads</li> <li>NUMA-sensitive applications</li> <li>IO-heavy pipelines</li> </ul>"},{"location":"use-case/#3-where-kloigos-is-not-a-good-fit","title":"3. Where Kloigos is not a good fit","text":"<p>Kloigos is not ideal for:</p> <ul> <li>untrusted internet-facing tenants (shared kernel risk)</li> <li>workloads needing strong kernel isolation guarantees</li> <li>ephemeral, stateless, image-based microservices</li> <li>teams deeply invested in Kubernetes</li> <li>workloads that rely on container ecosystems (sidecars, service mesh, etc.)</li> </ul> <p>Those users should stick with:</p> <ul> <li>Kubernetes</li> <li>microVMs (Firecracker)</li> <li>traditional VMs</li> </ul>"},{"location":"use-case/#4-how-wide-is-the-adaptability","title":"4. How wide is the adaptability?","text":""},{"location":"use-case/#conceptually","title":"Conceptually","text":"<p>Kloigos is adaptable to any environment that already runs Linux and systemd.</p> <p>It does not require:</p> <ul> <li>special kernels</li> <li>special hardware</li> <li>custom runtimes</li> <li>vendor lock-in</li> </ul> <p>That makes it portable and incrementally adoptable.</p>"},{"location":"use-case/#practically","title":"Practically","text":"<p>Kloigos is best described as:</p> <p>\u201cA Linux-native, VM-like abstraction layer for subdividing large machines.\u201d</p> <p>That\u2019s a niche - but it\u2019s a real and recurring niche, and it\u2019s underserved by existing tools.</p>"},{"location":"use-case/#5-why-this-niche-exists-and-persists","title":"5. Why this niche exists (and persists)","text":"<p>Many teams are stuck between:</p> <ul> <li>VMs \u2192 too heavy, too expensive</li> <li>Containers \u2192 too opinionated, too complex, too ephemeral</li> </ul> <p>Kloigos occupies the missing middle ground:</p> <ul> <li>stronger isolation than \u201cjust users\u201d</li> <li>simpler than Kubernetes</li> <li>lighter than VMs</li> <li>more flexible than containers</li> </ul> <p>This \u201cmiddle ground\u201d is surprisingly common in real-world ops.</p>"},{"location":"use-case/#6-the-strongest-argument-for-kloigos","title":"6. The strongest argument for Kloigos","text":"<p>The strongest argument isn\u2019t technical\u2014it\u2019s experiential:</p> <p>\u201cGive a developer SSH access, systemd, predictable resources, and no surprises.\u201d</p> <p>That\u2019s an incredibly powerful value proposition.</p> <p>Many engineers want:</p> <ul> <li>a small VM</li> <li>with guaranteed CPU and IO</li> <li>without having to understand Kubernetes internals</li> </ul> <p>Kloigos delivers exactly that.</p>"},{"location":"use-case/#7-final-honest-assessment","title":"7. Final honest assessment","text":"<p>Kloigos is not for everyone - and that\u2019s okay.</p> <p>It is:</p> <ul> <li>\u274c not a general-purpose cloud platform</li> <li>\u274c not a Kubernetes replacement</li> <li>\u274c not a security boundary for hostile tenants</li> </ul> <p>But it is:</p> <ul> <li>\u2705 a compelling alternative for a real, underserved segment</li> <li>\u2705 technically sound</li> <li>\u2705 operationally elegant</li> <li>\u2705 easy to reason about</li> <li>\u2705 easy to adopt incrementally</li> </ul> <p>We present Kloigos clearly as:</p> <p>\u201cVM-like compute units without VMs, built from native Linux primitives\u201d</p>"},{"location":"docs/architecture/","title":"Architecture overview","text":"<p>Kloigos is designed as a stateless, highly available control plane that manages compute units across one or more hosts using native Linux primitives. Its architecture cleanly separates the user interface, control logic, and persistent state, allowing each layer to scale and fail independently.</p>"},{"location":"docs/architecture/#core-components","title":"Core components","text":"<p>Kloigos is composed of three main components:</p>"},{"location":"docs/architecture/#web-application","title":"Web application","text":"<p>The web application provides a user-facing interface for interacting with Kloigos. It allows users to view compute units, inspect their state, and perform lifecycle operations directly from the browser.</p> <p>The web application is fully stateless. It does not store any local state and communicates exclusively with the Kloigos backend through its APIs. As a result, multiple instances of the web application can be deployed behind a load balancer to provide high availability and horizontal scalability.</p>"},{"location":"docs/architecture/#backend-service","title":"Backend service","text":"<p>The backend is implemented as a FastAPI application and serves as the control plane for Kloigos. It exposes APIs for provisioning, deprovisioning, and managing compute units, and coordinates all actions across hosts.</p> <p>To perform host-level operations\u2014such as creating users, configuring systemd slices, setting up filesystem paths, or enforcing network policies\u2014the backend delegates execution to Ansible, using <code>ansible-runner</code>. All operational logic is externalized into Ansible playbooks, keeping the backend thin and focused on orchestration rather than configuration details.</p> <p>Like the web application, the backend is completely stateless. It does not rely on local files or persistent storage, and any backend instance can handle any request. This enables multiple backend instances to run concurrently for redundancy and load sharing.</p>"},{"location":"docs/architecture/#persistent-state-cockroachdb","title":"Persistent state (CockroachDB)","text":"<p>All Kloigos state is stored in CockroachDB, which serves as the single source of truth for the system. This includes:</p> <ul> <li>compute unit definitions and metadata</li> <li>allocation and deallocation state</li> <li>host information</li> <li>user and resource mappings</li> <li>versioned Ansible playbooks (stored as compressed artifacts)</li> </ul> <p>By relying on CockroachDB\u2019s distributed, replicated architecture, Kloigos avoids single points of failure and supports strong consistency across multiple backend instances. The database ensures that all controllers observe the same state and can safely coordinate actions in a highly available setup.</p>"},{"location":"docs/architecture/#high-availability-by-design","title":"High availability by design","text":"<p>Because both the web application and the backend are stateless, they can be deployed on multiple servers without coordination between instances. High availability is achieved by:</p> <ul> <li>running multiple web application instances behind a load balancer</li> <li>running multiple backend instances in parallel</li> <li>using CockroachDB for durable, replicated state and coordination</li> </ul> <p>If a web or backend instance fails, traffic can be routed to another instance without loss of state or disruption to ongoing operations. All metadata and operational definitions, including playbooks, are preserved in the database.</p>"},{"location":"docs/architecture/#summary","title":"Summary","text":"<p>Kloigos follows a simple but robust architectural model:</p> <ul> <li>stateless control plane (web app + backend)</li> <li>externalized execution via Ansible</li> <li>strongly consistent, replicated state in CockroachDB</li> </ul> <p>This design allows Kloigos to scale horizontally, tolerate failures, and manage compute units reliably without introducing complex orchestration layers or runtime dependencies.</p>"},{"location":"docs/deployment/","title":"Deployment","text":"<p>There are many ways you can deploy Kloigos in Production. Below is just a general guidance. Given that Kloigos is a FastAPI app, you should also consult the guidance given in the official FastAPI deployment guide.</p>"},{"location":"docs/deployment/#1-system-environment-setup","title":"1. System &amp; Environment Setup","text":"<p>Prepare the server and initialize the Python environment.</p> <pre><code># Update system packages\nsudo apt update &amp;&amp; sudo apt upgrade -y\nsudo apt install python3-pip python3-venv nginx git -y\n\n# Clone the repository\ngit clone https://github.com/fabiog1901/kloigos\ncd kloigos\n\n# Create and activate virtual environment\npython3 -m venv venv\nsource venv/bin/activate\n\n# Install dependencies from requirements.txt\npip install -r requirements.txt\n\n# Install production-specific dependencies (not in requirements.txt)\npip install gunicorn uvicorn\n</code></pre>"},{"location":"docs/deployment/#2-systemd-service-configuration","title":"2. Systemd Service Configuration","text":"<p>Create a service file to manage the Kloigos process.</p> <p>File Path: <code>/etc/systemd/system/kloigos.service</code></p> <pre><code>[Unit]\nDescription=Gunicorn instance to serve Kloigos\nAfter=network.target\n\n[Service]\nUser=ubuntu\nGroup=www-data\nWorkingDirectory=/home/ubuntu/kloigos\nEnvironment=\"PATH=/home/ubuntu/kloigos/venv/bin\"\n# Runs Gunicorn with 4 workers using the Uvicorn worker class\nExecStart=/home/ubuntu/kloigos/venv/bin/gunicorn \\\n    -w 4 \\\n    -k uvicorn.workers.UvicornWorker \\\n    main:app \\\n    --bind unix:app.sock\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <p>Activation:</p> <pre><code>sudo systemctl start kloigos\nsudo systemctl enable kloigos\n</code></pre>"},{"location":"docs/deployment/#3-nginx-configuration","title":"3. Nginx Configuration","text":"<p>Configure Nginx as a reverse proxy to route external traffic to the Unix socket.</p> <p>File Path: <code>/etc/nginx/sites-available/kloigos</code></p> <pre><code>server {\n    listen 80;\n    server_name your_domain_or_ip;\n\n    location / {\n        include proxy_params;\n        proxy_pass http://unix:/home/ubuntu/kloigos/app.sock;\n    }\n}\n</code></pre> <p>Activation:</p> <pre><code># Link the config and restart Nginx\nsudo ln -s /etc/nginx/sites-available/kloigos /etc/nginx/sites-enabled\nsudo nginx -t\nsudo systemctl restart nginx\n</code></pre>"},{"location":"docs/deployment/#4-maintenance-monitoring","title":"4. Maintenance &amp; Monitoring","text":"Task Command View Live Logs <code>journalctl -u kloigos -f</code> Restart Application <code>sudo systemctl restart kloigos</code> Apply Code Changes <code>git pull &amp;&amp; sudo systemctl restart kloigos</code> Check App Status <code>systemctl status kloigos</code> <p>To finalize your production setup, you should secure your API with HTTPS. This is essential for modern web applications and required if you plan to handle sensitive data or authentication.</p> <p>The industry standard for this is Certbot from Let's Encrypt, which provides free, automated SSL certificates.</p>"},{"location":"docs/deployment/#securing-your-kloigos-with-https","title":"\ud83d\udd12 Securing your Kloigos with HTTPS","text":""},{"location":"docs/deployment/#1-install-certbot","title":"1. Install Certbot","text":"<p>Install Certbot and the Nginx plugin to automate the certificate challenge and configuration.</p> <pre><code>sudo apt install certbot python3-certbot-nginx -y\n</code></pre>"},{"location":"docs/deployment/#2-obtain-and-install-the-ssl-certificate","title":"2. Obtain and Install the SSL Certificate","text":"<p>Run the following command. Certbot will automatically read your Nginx configuration, find your <code>server_name</code>, and request a certificate for it.</p> <pre><code>sudo certbot --nginx -d your_domain.com\n</code></pre> <p>Note: Ensure your domain's A Record is already pointing to your server's IP address before running this, otherwise the validation will fail.</p> <p>During the process, Certbot will ask if you want to redirect all HTTP traffic to HTTPS. You should choose Yes (Option 2).</p>"},{"location":"docs/deployment/#3-automated-certificate-renewal","title":"3. Automated Certificate Renewal","text":"<p>Let's Encrypt certificates expire every 90 days. Certbot installs a timer that automatically handles renewals. You can verify it is working with a dry run:</p> <pre><code>sudo certbot renew --dry-run\n</code></pre>"},{"location":"docs/deployment/#the-complete-production-stack-summary","title":"\ud83c\udfd7\ufe0f The Complete Production Stack (Summary)","text":"<p>Now that you have the full guide, here is how the data flows through your production stack:</p> <ol> <li>Client: Requests <code>https://your_domain.com</code>.</li> <li>Nginx: Receives the encrypted request on port 443, decrypts it using the SSL certificate.</li> <li>Unix Socket: Nginx forwards the plain request to <code>app.sock</code>.</li> <li>Gunicorn: Picks up the request from the socket and assigns it to an available Uvicorn Worker.</li> <li>FastAPI: Processes the logic and returns the response back up the chain.</li> </ol>"},{"location":"docs/deployment/#final-check-list-before-launch","title":"Final Check List before Launch","text":"<ul> <li>\u2705 Firewall: Ensure your firewall allows traffic on ports 80 (HTTP) and 443 (HTTPS) using <code>sudo ufw allow 'Nginx Full'</code>.</li> <li>\u2705 Environment Variables: If your app uses <code>.env</code> files, ensure they are present in the <code>WorkingDirectory</code>.</li> <li>\u2705 Logs: Keep an eye on <code>journalctl -u kloigos -f</code> during the first hour of traffic to catch any hidden bugs.</li> </ul>"}]}